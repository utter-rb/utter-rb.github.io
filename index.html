<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>utter - welcome</title>
    <link rel="icon" type="image/png" href="img/logo.png" />
    <link rel="stylesheet" href="stylesheets/main.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js"></script>


  </head>
  <body>
    <div class="wrapper">
      <header>
	<img class="" src="img/logo.png"  alt="utter">
	<p></p>



      </header>
      <section>
	<h3>Quick Start</h3>

	<div class="highlight">
	  <pre> <code class='bash'>$ gem install utter</code></pre>
	</div>
	<p>install the utter ruby gem on your system</p>

	<div class="highlight">
	  <pre> <code class='bash'>$ utter classic</code></pre>
	</div>
	<p>generate an utter classic-style project</p>

	<div class="highlight">
	  <pre> <code class='bash'>$ utter package </code></pre>
	</div>
	<p>package an utter component as a gem</p>

	<div class="highlight">
	  <pre> <code class='bash'>$ utter deploy </code></pre>
	</div>
	<p>deploy an utter container component</p>

	<hr>
	<hr/>
	<br>

	<h3>Philosophy</h3>

	Utter Extenstions are software artifacts in the form of gems that act as bounded context knowledge extenstions form the core, supporting, and generic domains.

	Building a Software System often requires the utilization of knowledge from a number of different domains.
	An Utter Domain-specific Microservice is sourcecode artifact that encapsulates a Domain-driven Design bounded context of knowledge including its core domain, as well as supporting, and generic domains; all via middleware extensions.

	context is the setting in which a word or statment appears that determines its meaning.
	bounded context is the conditions(rules) under which a particular model is defined and applicable.

	Utter components are software artifacts that consume and produce messages.

	Utter project contains: service.rb, context.rb, core/, supporting/, generic/.

	isolated logical domain models (bounded contexts), isolated autonmous teams, isolated datastores.

	focus on a specific core domain, 
	while incorporating knowledge from other supporting, and generic domains, via extensions. 

	<dl>
	  <dt>
	  Components act as a Pure Functions
	  </dt>
	  clear ordering of what is going to happen, 
	  very clear dependencies as they are pure functions (A pure function is a function where the return value is only determined by its input values, without observable side effects.),
	  very easy to test,

	  (Pure Functions are good!)
	When a function performs any other “action”, apart from calculating its return value, the function is impure. It follows that a function which calls an impure function is impure as well. Impurity is contagious.

Referential Transparency: Any invocation of an Utter component(pure function) can always be replaced by its result. 
(write domain extenstion example) There’s no difference between Math.cos(Math::PI) and -1; we can always replace the first with the second. 

Localized State: A pure function can only access what you pass it, so it’s easy to see its dependencies. We don’t always write functions like this. When a function accesses some other program state, such as an instance or global variable, it is no longer pure.



	  <dt>
	  Everything is a Component
	  </dt>


	  Utter components keeps a low line count as they are context specific thus approachable by new hires mapping to an overall low cost.

	  Utter projects have high availability via modular, partial deployments of individual microservices.
	  Utter perceives a microservice project as a single service, a single domain, and a number of domain-extenstions.
	  The service could have a number of endpoints that are part of the whole system API in production when mounted.
	  The domain is an isolated bounded-context refined at well-balanced scale with respect to the whole system.
	  The objective of this domain isolation is to limit complexity of a solution, 
	  via providing the means for the domain-experts to engage in providing the solution.
	  The domain could have a Domain-specific language (DSL) that aids in attaining experts' aid in tackling the domain challenges.
	  Domain-extenstions are the means for incorportating knowledge from domains(supporting, generic) in a packagable manner.
	  Usually your system will be composed out of a number of microservices. Each of those microservices shall contain a service component, a domain component, and a number of domain extenstion components. 
	  Utter components are easily testable, with clear dependencies, and easy to understand as they follow a common functional interface structure.
	  Utter components are independently replaceable and independently upgradable.
	  Every component granularity is dictated via the role it acts, in relevance to the context in which it will be represented. 
<!--
	  <dt>
	  Everything is Usable 
	  </dt>
	  Utter generates context-aware system components, e.g. standalone microservices vs project embedded microservices.
	  The Utter way guides you into dividing your system into fine-grained components,
	  making sure that every system component you develop is simple enough to be understood by others, hence openly usable in a sharing culture.

	  <dt>
	  Everything is Reusable 
	  </dt>
	  Utter components are versioned packageable gems, meaning any utter component is one command away form being distributed to the community.
-->
	</dl>

	<hr/>
	<br>

	<h3>Sample Apps</h3>

	<dl>
	  <dt>
	  Utter classic-Style is well-suited to individuals for building <span> whole </span> domain-specific microservcies as single distributable gems, <a class="modal-trigger waves-effect waves-light" href="#classic_sample">Check Sample</a>.
	  </dt>
	  <br>
	  <br>
	  <dt>
	  Utter modular-style is well-suited to small teams for building <span> independent </span> utter domain-specific microservice components as multiple distributable gems, <a class="modal-trigger waves-effect waves-light" href="#modular_sample">Check Sample</a>.
	  </dt>
	</dl>

	<!-- classic_sample Modal Structure -->
	<div id="classic_sample" class="modal modal-fixed-footer">
	  <div class="modal-content">
	    <h4>Utter Classic</h4>
	    <p>A bunch of text</p>
	    <p>A bunch of text</p>
	    <p>A bunch of text</p>

	    <div class="highlight">
	      <pre>
Classic-style
<code class='bash'>$ gem install utter 
$ utter classic 
	      </code></pre>
	    </div>

	    <div class="highlight">
	      <pre> <code class='ruby'>
# Usage
# Inbounds down the stack A -> B -> C, then 
# Outbounds up the stack C -> B -> A
Utter::Stack.new do
 use A
 use B
 use C
end
	      </code></pre>
	    </div>
	    <p>generate an utter classic-style project</p>

	    <div class="highlight">
	      <pre> <code class='bash'>$ utter package </code></pre>
	    </div>
	    <p>package an utter component as a gem</p>

	    <div class="highlight">
	      <pre> <code class='bash'>$ utter deploy </code></pre>
	    </div>
	    <p>deploy an utter container component</p>
	    <h6> For further support visit #utter @irc.freenode.net </h6>
	  </div>
	  <div class="modal-footer">
	    <p class="modal-footer-content">
	    <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat ">Awesome, Got it!</a>
	    </p>
	  </div>
	</div>


	<!-- modular_sample Modal Structure -->
	<div id="modular_sample" class="modal modal-fixed-footer">
	  <div class="modal-content">
	    <h4>Utter Modular</h4>
	    <p>A bunch of text</p>
	    <p>A bunch of text</p>
	    <p>A bunch of text</p>
	<div class="highlight">
	  <pre>
Modular-style (Still in Experimental Stage)
<code class='bash'>$ gem install utter 
# Wizards through multiple utter components
$ utter modular 
# Wizards an individual utter component
$ utter container 
$ utter service
$ utter domain

# Your packged microservice can be installed and used
$ gem install mycomapny::v1::transfers
$ mycomapny::v1::transfers up
$ mycomapny::v1::transfers down 
$ mycomapny::v1::transfers status

# Utter extenstions are middlewares that enables interoperability among core domain-knowledge, supporting domain-knoweldge, and generic domain-knowledge components; via providing the means for exchanging knowledge in a standardrized manner. 
$ utter ext

$ utter auth-provider-service
$ utter auth-consumer-ext
	  </code></pre>
	</div>

	    <div class="highlight">
	      <pre> <code class='bash'>$ utter classic</code></pre>
	    </div>
	    <p>generate an utter classic-style project</p>

	    <div class="highlight">
	      <pre> <code class='bash'>$ utter package </code></pre>
	    </div>
	    <p>package an utter component as a gem</p>

	    <div class="highlight">
	      <pre> <code class='bash'>$ utter deploy </code></pre>
	    </div>
	    <p>deploy an utter container component</p>
	  </div>
	  <div class="modal-footer">
	    <p class="modal-footer-content">
	    <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat ">Awesome, Got it!</a>
	    <h6> #utter @irc.freenode.net </h6>
	    </p>
	  </div>
	</div>


	<hr/>
	<br>


	<h3>Open Source</h3>
	<p>Can we do better? Utter is opensource, meaning if you like to adjust it for the betterment of your experiance, as well as others, you can simply start engaging via reading the  <a href="https://utter-rb.github.io/">source</a>, <a href="https://github.com/utter-rb/utter/fork">forking</a> it, or via <a href="https://github.com/utter-rb/utter/issues/new">submitting a feature request\reporting a bug</a> to improve it, all contributions count! 
	</p>
	<p>

	</p>
	<hr/>
	<br>

	<h3>License</h3>
	<p>MIT license</p>
	<hr/>

	<h3>Community</h3>
	<p> Join the discussion at #utter on irc.freenode.net </p>

	<hr/>
	<br>

	<h3>Consulting\Training</h3>
	<p> <a href="https://hackspree.com">hackspree.com</a> </p>
	<p> [add your company here] </p>
	<hr/>
	<br>


	<h3>Credits</h3>
	<p> <a href="https://twitter.com/ericevans0">Eric Evans</a> - <strong> DDD & Microservices: At Last, Some Boundaries!</strong> </p>
	<p> <a href="https://twitter.com/mitchellh">Mitchell Hashimoto </a> - <strong>Rack Middleware as a General Purpose Abstraction </strong> </p>
	<p> <a href="https://twitter.com/richhickey">Rich Hickey</a> - <strong>Simplicity Matters</strong> </p>

	<p> <a href="https://twitter.com/unclebobmartin">Robert Cecil Martin </a> - <strong>Architecture the Lost Years</strong> </p>
	<br>
	<hr/>
	<br>



      </section>

      
      <footer>
	<p> <h6> Utter is a Domain-specific Microservices Framework written in Ruby. 
	</h6>
	</p>
	<a href="https://badge.fury.io/rb/utter"><img src="https://badge.fury.io/rb/utter@2x.png" alt="Gem Version" height="18"></a>


      </footer>
    </div>


    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/main.js"></script>

  </body>
</html>
