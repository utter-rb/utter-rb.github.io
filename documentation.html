<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>mushin - documentation</title>

    <link rel="icon" type="image/png" href="img/logo2.png" />
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapperdoc">
<!--
      <header>
      <img src="img/logo2.png" alt="mushin">
      </header>
      -->
      <h3>Mushin Documentation</h3>

      <p>Ruby's Domain Frameworks Generator</p>

      <div class="highlight">
<pre>
<code class='bash'>$ mushin roll [your-own-domain-framework]
</code></pre>
      </div>

      <p>the mushin gem enables you to generate rich <strong>DDD 2.0</strong> frameworks based-on your application's core domain, and publish it in secs!</p>
      <hr/>
      <br>

      <h3>Mushin Documentation</h3>
"the grestest value of a domain model is that provides a ubiquitous language that ties domain experts and technologists together"

"really powerful domain models evolve over time"[develop your own domain dsl code in the framework]

"even the most experienced modelers find that they gain their best ideas after the initial releases of
a system."[feel free to publish incremented versions of your domain framework]

"Although their use of technology was not exemplary, it was the business logic that over-came them. Their first release had ossified
prematurely into a high-maintenance legacy."

"Developers and domain experts have a close relationship. Domain-driven design crunches a huge amount of knowledge into a model that reflects deep insight into the domain and a focus on the key concepts. This is a collaboration between those who know the domain and those who know how to build software. Because development is iterative, this collaboration must continue throughout the project's life."

"Domain-Driven Team"[mushin's ecosystem makes it easy to advertise for domain experiance and respective tools rather than pure technology, hence a more thoughtful talent aquision] 

"Domain-driven design is a difficult technical challenge that can pay off big, opening opportunities just when most software projects begin to ossify into legacy."

"A model is asimplification. It is an interpretation of reality that abstracts the aspects relevant to solving the problem at hand and ignores extraneous detail."


"The model is distilled knowledge. The model is the team's agreed-upon way of structuring domain knowledge and distinguishing the elements of most interest."

"domain development holds opportunities to cultivate very sophisticated design skills."

"Meanwhile, all projects leak knowledge. People who have learned something move on.
Reorganization scatters the team, and the knowledge is fragmented again. Crucial subsystems are
out-sourced in such a way that code is delivered but knowledge isn't. And with typical design
approaches, the code and documents don't express this hard-earned knowledge in a usable form,
so when the oral tradition is interrupted for any reason, the knowledge is lost."[domain middleware gems are meant to encapsulate this knowledge into reusable fragments of code]

"First of all, the term “Layered Architecture” means that you partition an application into layers:
User Interface. Responsible for showing information to the user and processing the user’s input.
Application Layer. This layer is supposed to be thin and it should not contain any domain logic. It can have functionality that is valuable for the business but is not “domain” specific. This includes generating reports, sending email notifications etc."
Domain Layer. Responsible for describing business processes. Abstract domain concepts (including entities, business rules) must be contained in this layer. In contrast, persistence, message sending do not belong here.
Infrastructure Layer. Responsible for persistence, messaging, email delivery etc."

"Persistent use of the UBIQUITOUS LANGUAGE will force the model's weaknesses into the open"

"Committed to using this language in the context of implementation, the developers will point out imprecision or contradictions, engaging the domain experts in discovering workable alternatives."

"The use of language on a project is subtle but all-important. . . ."

"Infrastructure Layer - Provides generic technical capabilities that support the higher layers:
message sending for the application, persistence for the domain, drawing
widgets for the UI, and so on. The infrastructure layer may also support
the pattern of interactions between the four layers through an
architectural framework."

"Separating the domain layer from the infrastructure and user interface layers allows a much
cleaner design of each layer. Isolated layers are much less expensive to maintain, because they
tend to evolve at different rates and respond to different needs."

"It is not practical to achieve that correspondence when the domain logic is mixed with other
concerns of the program. Isolating the domain implementation is a prerequisite for domain-driven
design."

"Does an object represent something with continuity and identity—something that is tracked
through different states or even across different implementations? Or is it an attribute that
describes the state of something else? This is the basic distinction between an ENTITY and a VALUE
OBJECT."

"Entity Objects aka Reference Objects: Many objects are not fundamentally defined by their attributes, but rather by a thread of
continuity and identity"

"we could share just one instance of an
outlet and point to it a hundred times (an example of FLYWEIGHT [Gamma et al. 1995]). In large
systems, this kind of effect can be multiplied by thousands, and such an optimization can make
the difference between a usable system and one that slows to a crawl, choked on millions of
redundant objects. This is just one example of an optimization trick that is not available for
ENTITIES."

"simplicity is a choice, requires vigilance, sensibilities and care!"

"When a significant process or transformation in the domain is not a natural
responsibility of an ENTITY or VALUE OBJECT, add an operation to the model as a
standalone interface declared as a SERVICE. Define the interface in terms of the
language of the model and make sure the operation name is part of the UBIQUITOUS
LANGUAGE. Make the SERVICE stateless."

[It is a truism that there should be low coupling between MODULES and high cohesion
within them. Explanations of coupling and cohesion tend to make them sound like
technical metrics, to be judged mechanically based on the distributions of associations
and interactions. Yet it isn't just code being divided into MODULES, but concepts. There is
a limit to how many things a person can think about at once (hence low coupling).
Incoherent fragments of ideas are as hard to understand as an undifferentiated soup of
ideas (hence high cohesion)"[same as domain frameworks and domain middlewares]

"Give the MODULES names that become part of the UBIQUITOUS LANGUAGE. MODULES and
their names should reflect insight into the domain."

"Inevitable early mistakes in MODULE choices lead to high coupling, which makes it hard to refactor.
The lack of refactoring just keeps increasing the inertia."

"If the framework's partitioning conventions pull apart the elements implementing the
conceptual objects, the code no longer reveals the model."

"There is only so much partitioning a mind can stitch back together, and if the framework uses
it all up, the domain developers lose their ability to chunk the model into meaningful pieces."

"Use packaging to separate the domain layer from other code. Otherwise, leave as much
freedom as possible to the domain developers to package the domain objects in ways
that support their model and design choices."

"Many of the reasons teams choose the object paradigm are not technical, or even intrinsic to
objects. But right out of the gate, object modeling does strike a nice balance of simplicity and
sophistication"

"If a modeling paradigm is too esoteric, not enough developers will master it, and they will use it
badly. If the nontechnical members of the team can't grasp at least the rudiments of the
paradigm, they will not understand the model, and the UBIQUITOUS LANGUAGE will be lost."

"Cluster the ENTITIES and VALUE OBJECTS into AGGREGATES and define boundaries around
each. Choose one ENTITY to be the root of each AGGREGATE, and control all access to the
objects inside the boundary through the root. Allow external objects to hold references
to the root only. Transient references to internal members can be passed out for use
within a single operation only. Because the root controls access, it cannot be blindsided
by changes to the internals. This arrangement makes it practical to enforce all
invariants for objects in the AGGREGATE and for the AGGREGATE as a whole in any state
change. It can be very helpful to have a technical framework that allows you to declare AGGREGATES and
then automatically carries out the locking scheme and so forth. Without that assistance, the team
must have the self-discipline to agree on the AGGREGATES and code consistently with them."[this looks the same as the nested DSL generator]


<h3>migrating from DDD 1.0 to DDD 2.0 </h3>
Repository Pattern -> Autonomous Presistance Datastore(s) 
aggreate design -> middlewares
"Domain Layer. Responsible for describing business processes. Abstract domain concepts (including entities, business rules) must be contained in this layer. In contrast, persistence, message sending do not belong here."[in DDD 2.0 layerd architecture, domain layer consists of a middleware framework with plugable middlewares including some presistance middlewares opposite to DDD 1.0 where presistance was included into its own layer infrastructure layer]

<h3>Project Development under DDD 2.0 </h3>
you decide to add certain domains to your project and seekout experinced 'domain experts' or developers to do your project.
<h3>What's next? </h3>
nested domains, where security domain framework can nest fronsics and web vurlanability domain frameworks?
OR domainA middleware ->> REST Binding -->> domainB middleware or domainB framework

mushin should provide REST binding helpers?

<br>

    </div>

    <script src="javascripts/scale.fix.js"></script>
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
      </script>
      <script type="text/javascript">
	try {
	  var pageTracker = _gat._getTracker("UA-51567040-1");
	  pageTracker._trackPageview();
	} catch(err) {}
      </script>

    </body>
  </html>
